pipeline {
    agent any

    options {
        timestamps()
    }

    environment {
        // 镜像仓库配置
        REGISTRY = '47.120.49.65:5001'
        IMAGE_NAME = 'micro-svc/test-golang-helloworld'
        APP_NAME = 'test-golang-helloworld'
        // 版本配置 - 可通过参数覆盖
        VERSION = "${params.VERSION ?: 'latest'}"
        NAMESPACE = 'xyz-dev'
        K8S_DEPLOYMENT_FILE_ID = 'deployment-template-go'

        // GitLab 私仓域名
        GITLAB_HOST = 'lab.pistonint.com'
        K8S_CONFIG = credentials('jenkins-k8s-config')
    }

    stages {
        stage('Go Build') {
            agent {
                docker {
                    image 'golang:1.25'
                    args '-u root:root'
                    reuseNode true
                }
            }
            steps {
                echo '开始 Go 构建...'
                checkout scm
                script {
                    env.GIT_SHA = sh(returnStdout: true, script: 'git rev-parse --short=8 HEAD').trim()
                    echo "当前提交: ${env.GIT_SHA}"
                }
                withCredentials([usernamePassword(
                        credentialsId: 'gitlab-secret',
                        usernameVariable: 'GIT_USERNAME',
                        passwordVariable: 'GIT_PASSWORD')]
                ) {
                    sh label: 'Go build in container', script: '''
                        set -eux
                        go version
                        
                        # 首先配置 Go 环境变量，避免访问 proxy.golang.org
                        go env -w GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy,direct
                        go env -w GOSUMDB=off
                        go env -w GOOS=linux 
                        go env -w GOARCH=arm64 
                        go env -w CGO_ENABLED=0 
                        go env -w GOPRIVATE=$GITLAB_HOST/* 
                        go env -w GONOSUMDB=$GITLAB_HOST/*
                        
                        # 然后配置 Git 私仓凭据
                        git config --global url."https://${GIT_USERNAME}:${GIT_PASSWORD}@${GITLAB_HOST}/".insteadOf "https://${GITLAB_HOST}/"

                        # 验证 Go 环境配置
                        echo "=== Go 环境配置 ==="
                        go env GOPROXY GOSUMDB GOPRIVATE GONOSUMDB
                        echo "=================="

                        # 拉取依赖并构建（校验可编译）
                        # 设置超时和重试，避免网络问题
                        timeout 300s bash -c '
                            for i in {1..3}; do
                                echo "尝试下载依赖 (第 $i 次)..."
                                if go mod download; then
                                    echo "依赖下载成功！"
                                    break
                                else
                                    echo "依赖下载失败 (第 $i 次)"
                                    if [ $i -eq 3 ]; then
                                        echo "所有重试都失败了"
                                        exit 1
                                    fi
                                    sleep 10
                                fi
                            done
                        '
                        
                        go build -ldflags="-w -s" -o helloworld-server main.go
                        
                        ls -la

                        # 清理 git 临时凭据映射（避免后续泄露）
                        git config --global --unset-all url."https://$GIT_USERNAME:$GIT_PASSWORD@$GITLAB_HOST/".insteadOf || true
                    '''
                }
            }
        }

        stage('Docker Build') {
            steps {
                echo '开始构建Docker镜像多平台构建，然后镜像推送到镜像注册中心...'
                script {
                    withCredentials([usernamePassword(
                            credentialsId: 'docker-registry-secret',
                            usernameVariable: 'GIT_USERNAME',
                            passwordVariable: 'GIT_PASSWORD')]
                    ) {
                        sh label: 'Docker build with GitLab credentials', script: '''
                            set -eux
                            # 启用 BuildKit
                            export DOCKER_BUILDKIT=1
                            
                            # 检查 buildx 是否可用
                            if docker buildx version >/dev/null 2>&1 && docker buildx inspect jenkins-builder >/dev/null 2>&1; then
                                echo "✅ 使用 buildx 构建镜像..."
                                docker buildx build \
                                  --platform linux/arm64/v8,linux/amd64 \
                                  --tag $REGISTRY/$IMAGE_NAME:$VERSION \
                                  --build-arg PLATFORM=linux/arm64/v8 \
                                  --push \
                                  .
                            else
                                echo "⚠️ buildx 不可用，使用传统构建方式..."
                                docker build \
                                  -t $REGISTRY/$IMAGE_NAME:$VERSION \
                                  .
                            fi
                        '''
                    }
                }
            }
        }

        stage('k8s发布') {
            agent {
                docker {
                    image 'bitnami/kubectl:latest'
                    args '-u root:root --entrypoint ""'
                }
            }
            steps {
                withKubeConfig([credentialsId: "jenkins-k8s-config",
                                serverUrl    : "https://kubernetes.default.svc.cluster.local"]) {
                    // 使用 configFile 插件，创建 Kubernetes 部署文件 deployment.yaml
                    configFileProvider([configFile(
                            fileId: "${K8S_DEPLOYMENT_FILE_ID}",
                            targetLocation: "deployment.tpl")
                    ]) {
                        script {
                            sh "cat deployment.tpl"
                            def deployTemplate = readFile(encoding: "UTF-8", file: "deployment.tpl")
                            def deployment = deployTemplate
                                    .replace("{APP_NAME}", "${APP_NAME}")
                                    .replace("{NAMESPACE}", "${NAMESPACE}")
                                    .replace("{REGISTRY}", "${REGISTRY}")
                                    .replace("{IMAGE_NAME}", "${IMAGE_NAME}")
                                    .replace("{VERSION}", "${VERSION}")
                            writeFile(encoding: 'UTF-8', file: './deploy.yaml', text: "${deployment}")
                        }

                        // 输出新创建的部署 yaml 文件内容
                        sh "cat deploy.yaml"
                        // 执行 Kuberctl 命令进行部署操作
                        // sh "kubectl apply -n ${NAMESPACE} -f deploy.yaml"
                    }
                }
            }
        }
    }

    post {
        always {
            echo '构建结束......'
            sh 'docker image ls | head -n 20 | cat'
        }
        success {
            script {
                echo "构建完成，镜像地址: $REGISTRY/$IMAGE_NAME:$VERSION"
                cleanWs()
                echo '✅ 构建成功！'
                echo "📦 镜像已推送到: $REGISTRY/$IMAGE_NAME:$VERSION"
            }
        }
        failure {
            echo '❌ 构建失败！'
        }
        aborted {
            echo '⚠️ 构建被中止'
        }
    }
}
